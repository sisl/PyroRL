{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyroRL PyroRL is a new reinforcement learning environment built for the simulation of wildfire evacuation. Motivation A major effect of climate change today is the increased frequency and intensity of wildfires. This reality has led to increased research in wildfire response, particularly with reinforcement learning (RL). While much effort has centered on modeling wildfire spread or surveillance, wildfire evacuation has received less attention. We present PyroRL, a new RL environment for wildfire evacuation. The environment, which builds upon the Gymnasium API standard, simulates evacuating populated areas through paths from a grid world containing wildfires. This work can serve as a basis for new strategies for wildfire evacuation.","title":"Home"},{"location":"#pyrorl","text":"PyroRL is a new reinforcement learning environment built for the simulation of wildfire evacuation.","title":"PyroRL"},{"location":"#motivation","text":"A major effect of climate change today is the increased frequency and intensity of wildfires. This reality has led to increased research in wildfire response, particularly with reinforcement learning (RL). While much effort has centered on modeling wildfire spread or surveillance, wildfire evacuation has received less attention. We present PyroRL, a new RL environment for wildfire evacuation. The environment, which builds upon the Gymnasium API standard, simulates evacuating populated areas through paths from a grid world containing wildfires. This work can serve as a basis for new strategies for wildfire evacuation.","title":"Motivation"},{"location":"api/","text":"API Reference We provide API documentation for the public endpoints that are intended to be utilized by the end user. Namely, we describe the functionality of our wildfire evacuation environment and our map generation functions. WildfireEvacuationEnv Below are the member functions for the core wildfire evacuation environment, which is an extension of the Gymnasium API Standard. __init__ __init__( self, num_rows: int, num_cols: int, populated_areas: np.ndarray, paths: np.ndarray, paths_to_pops: dict, num_fire_cells: int = 2, custom_fire_locations: Optional[np.ndarray] = None, wind_speed: Optional[float] = None, wind_angle: Optional[float] = None, fuel_mean: float = 8.5, fuel_stdev: float = 3, fire_propagation_rate: float = 0.094, skip: bool = False, ): This function is the constructor for our wildfire environment. Parameters num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area. num_fire_cells ( int ) -- The number of fires the user wishes to start the simulation with. custom_fire_locations ( Optional[np.ndarray] ) -- A user can specify the exact location fires will start at. Overrides num_fire_cells if given by user. wind_speed ( optional[float] ) -- Optional parameter specifying the speed of wind to affect fire propogation patterns. If used, user must also specify wind_angle. wind_angle ( optional[float] ) -- Optional parameter specifying the angle of wind in radians to affect fire propogation patterns. If used, user must also specify wind_speed. fuel_mean ( float ) -- Mean in normal distribution to decide the amount of fuel in a given cell. fuel_stdev ( float ) -- Standard deviation in normal distribution to decide the amount of fuel in a given cell. fire_propagation_rate ( float ) -- Proportional scaling term to describe the chance an enflamed cell lights another cell. skip ( bool ) -- If set to true, calls to visualization will not display visualization at runtime, but just save data for post simulation complete visualization. Return Values None reset WildfireEvacuationEnv.reset( self, seed: Optional[int] = None, options: Optional[dict[str, Any]] = None ) -> tuple[np.ndarray, dict[str, Any]]: This function resets the wildfire environment to its initial state. Parameters seed ( Optional[int] ) -- Ignored options ( Optional[dict[str, Any]] ) -- Ignored Return Values state_space ( np.ndarray ) -- The reset state space after performing the action info ( dict ) -- Ignored step WildfireEvacuationEnv.step(self, action: int) -> tuple This function takes an action in the wildfire environment and also updates the corresponding state space. Parameters action ( int ) -- the action to take in our environment. In this context, the action is sampled from the environment's action_space and corresponds to evacuating a singular populated area from a singular path. Return Values observations ( np.ndarray ) -- The updated state space after performing the action rewards ( int ) -- The reward accrued after taking an action terminated ( bool ) -- Whether or not the simulation has come to an end truncated ( bool ) -- Ignored info ( dict ) -- Ignored render WildfireEvacuationEnv.render(self) -> None This function renders the environment in a Pygame grid for the user to visualize or save. Parameters None Return Values None generate_gif WildfireEvacuationEnv.generate_gif(self) -> None This function saves a stitched GIF of all visualizations rendered by the user. Parameters None Return Values None create_map_info Below are the member functions for the helper fiile that helps generate maps dynamically. load_map_info create_map_info.load_map_info(map_directory_path: str) -> tuple: This function loads in the saved information for a grid. Parameters map_directory_path ( str ): The path for the subdirectory where the data for the relevant grid is stored. Return Values num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area. num_populated_areas ( int ) -- The number of populated areas on the grid. generate_map_info generate_map_info( num_rows: int, num_cols: int, num_populated_areas: int, save_map: bool = True, steps_lower_bound: int = 2, steps_upper_bound: int = 4, percent_go_straight: int = 50, num_paths_mean: int = 3, num_paths_stdev: int = 1, ) -> tuple: This function generates the data needed to create a grid. Parameters num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. num_populated_areas ( int ) -- The number of populated areas in the grid. save_map ( bool ) -- Whether or not the information for the map generation should be saved for later use. steps_lower_bound ( int ) -- The lower bound for the random generation of how many steps are taken during each iteration of a path creation.t- steps_upper_bound ( int ) -- The upper bound for the random generation of how many steps are taken during each iteration of a path creation. percent_go_straight ( int ) -- What percent of the time a path will try to continue straight rather than taking a turn. num_paths_mean ( int ) -- The mean of the normal distribution that is sampled from to determine the number of paths for a populated area. num_paths_stdev ( int ) -- The standard deviation of the normal distribution that is sampled from to determine the number of paths for a populated area. Return Values populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area.","title":"API Reference"},{"location":"api/#api-reference","text":"We provide API documentation for the public endpoints that are intended to be utilized by the end user. Namely, we describe the functionality of our wildfire evacuation environment and our map generation functions.","title":"API Reference"},{"location":"api/#wildfireevacuationenv","text":"Below are the member functions for the core wildfire evacuation environment, which is an extension of the Gymnasium API Standard.","title":"WildfireEvacuationEnv"},{"location":"api/#__init__","text":"__init__( self, num_rows: int, num_cols: int, populated_areas: np.ndarray, paths: np.ndarray, paths_to_pops: dict, num_fire_cells: int = 2, custom_fire_locations: Optional[np.ndarray] = None, wind_speed: Optional[float] = None, wind_angle: Optional[float] = None, fuel_mean: float = 8.5, fuel_stdev: float = 3, fire_propagation_rate: float = 0.094, skip: bool = False, ): This function is the constructor for our wildfire environment.","title":"__init__"},{"location":"api/#parameters","text":"num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area. num_fire_cells ( int ) -- The number of fires the user wishes to start the simulation with. custom_fire_locations ( Optional[np.ndarray] ) -- A user can specify the exact location fires will start at. Overrides num_fire_cells if given by user. wind_speed ( optional[float] ) -- Optional parameter specifying the speed of wind to affect fire propogation patterns. If used, user must also specify wind_angle. wind_angle ( optional[float] ) -- Optional parameter specifying the angle of wind in radians to affect fire propogation patterns. If used, user must also specify wind_speed. fuel_mean ( float ) -- Mean in normal distribution to decide the amount of fuel in a given cell. fuel_stdev ( float ) -- Standard deviation in normal distribution to decide the amount of fuel in a given cell. fire_propagation_rate ( float ) -- Proportional scaling term to describe the chance an enflamed cell lights another cell. skip ( bool ) -- If set to true, calls to visualization will not display visualization at runtime, but just save data for post simulation complete visualization.","title":"Parameters"},{"location":"api/#return-values","text":"None","title":"Return Values"},{"location":"api/#reset","text":"WildfireEvacuationEnv.reset( self, seed: Optional[int] = None, options: Optional[dict[str, Any]] = None ) -> tuple[np.ndarray, dict[str, Any]]: This function resets the wildfire environment to its initial state.","title":"reset"},{"location":"api/#parameters_1","text":"seed ( Optional[int] ) -- Ignored options ( Optional[dict[str, Any]] ) -- Ignored","title":"Parameters"},{"location":"api/#return-values_1","text":"state_space ( np.ndarray ) -- The reset state space after performing the action info ( dict ) -- Ignored","title":"Return Values"},{"location":"api/#step","text":"WildfireEvacuationEnv.step(self, action: int) -> tuple This function takes an action in the wildfire environment and also updates the corresponding state space.","title":"step"},{"location":"api/#parameters_2","text":"action ( int ) -- the action to take in our environment. In this context, the action is sampled from the environment's action_space and corresponds to evacuating a singular populated area from a singular path.","title":"Parameters"},{"location":"api/#return-values_2","text":"observations ( np.ndarray ) -- The updated state space after performing the action rewards ( int ) -- The reward accrued after taking an action terminated ( bool ) -- Whether or not the simulation has come to an end truncated ( bool ) -- Ignored info ( dict ) -- Ignored","title":"Return Values"},{"location":"api/#render","text":"WildfireEvacuationEnv.render(self) -> None This function renders the environment in a Pygame grid for the user to visualize or save.","title":"render"},{"location":"api/#parameters_3","text":"None","title":"Parameters"},{"location":"api/#return-values_3","text":"None","title":"Return Values"},{"location":"api/#generate_gif","text":"WildfireEvacuationEnv.generate_gif(self) -> None This function saves a stitched GIF of all visualizations rendered by the user.","title":"generate_gif"},{"location":"api/#parameters_4","text":"None","title":"Parameters"},{"location":"api/#return-values_4","text":"None","title":"Return Values"},{"location":"api/#create_map_info","text":"Below are the member functions for the helper fiile that helps generate maps dynamically.","title":"create_map_info"},{"location":"api/#load_map_info","text":"create_map_info.load_map_info(map_directory_path: str) -> tuple: This function loads in the saved information for a grid.","title":"load_map_info"},{"location":"api/#parameters_5","text":"map_directory_path ( str ): The path for the subdirectory where the data for the relevant grid is stored.","title":"Parameters"},{"location":"api/#return-values_5","text":"num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area. num_populated_areas ( int ) -- The number of populated areas on the grid.","title":"Return Values"},{"location":"api/#generate_map_info","text":"generate_map_info( num_rows: int, num_cols: int, num_populated_areas: int, save_map: bool = True, steps_lower_bound: int = 2, steps_upper_bound: int = 4, percent_go_straight: int = 50, num_paths_mean: int = 3, num_paths_stdev: int = 1, ) -> tuple: This function generates the data needed to create a grid.","title":"generate_map_info"},{"location":"api/#parameters_6","text":"num_rows ( int ) -- The number of rows in the grid. num_cols ( int ) -- The number of columns in the grid. num_populated_areas ( int ) -- The number of populated areas in the grid. save_map ( bool ) -- Whether or not the information for the map generation should be saved for later use. steps_lower_bound ( int ) -- The lower bound for the random generation of how many steps are taken during each iteration of a path creation.t- steps_upper_bound ( int ) -- The upper bound for the random generation of how many steps are taken during each iteration of a path creation. percent_go_straight ( int ) -- What percent of the time a path will try to continue straight rather than taking a turn. num_paths_mean ( int ) -- The mean of the normal distribution that is sampled from to determine the number of paths for a populated area. num_paths_stdev ( int ) -- The standard deviation of the normal distribution that is sampled from to determine the number of paths for a populated area.","title":"Parameters"},{"location":"api/#return-values_6","text":"populated_areas ( np.ndarray ) -- A numpy array containing the information of the location of every populated area in the map. Formatting is specified as [[row_i,col_i],[row_i, col_i]] paths ( np.ndarray ) -- A numpy array of type object where each element represents a list of locations taken by a single path. Formatting is specified for j as [[[row_{j0},col_{j0}],[row_{j1},col_{j1}]]_j] paths_to_pops ( dict ) -- The i'th path specified in paths is specified by the key i in this dict which leads to a location of a populated area specified in populated_areas to identify that path as servicing that populated area.","title":"Return Values"},{"location":"contact/","text":"Contact You can find our codebase at the following Github link . If you have any questions about how to use our package or contribute to the project, create an issue or reach out directly to our team: clpondoc@cs.stanford.edu jobrien3@cs.stanford.edu joeytg@cs.stanford.edu","title":"Contact"},{"location":"contact/#contact","text":"You can find our codebase at the following Github link . If you have any questions about how to use our package or contribute to the project, create an issue or reach out directly to our team: clpondoc@cs.stanford.edu jobrien3@cs.stanford.edu joeytg@cs.stanford.edu","title":"Contact"},{"location":"contribution-guide/","text":"Contribution Guide To get started on contributing, check out the below guide on how to get the package installed locally, how to update this documentation website, and more. How to Set-Up To set up our codebase, create a virtual environment and install a local copy of the package. python3 -m venv env source env/bin/activate cd pyrorl/ pip install . Package Deployment All of the details of the package can be found in pyrorl/setup.py . This file defines attributes such as the name of the package, the version number, and the dependencies needed to use the package. Next, you build the distribution archives. Archives are compressed files that allow the package to be deployed across multiple platforms. You run the following command to generate the distribution files: python3 setup.py sdist Using the above command should generate a dist folder, which contains the compressed distribution files. Finally, we can publish it to the official PyPi repository using a package called twine : twine upload dist/* Doing the * will upload all of the compressed distribution files, so ideally, we would clear out all of them and then have only one set of distribution files. Coding Standards Testing We use pytest for our backend tests. To keep the state of our package as small as possible, we don't include pytest . Thus, make sure to install the package before running. pip install pytest python3 -m pytest -s Linting We use flake8 for linting. We also don't install flake8 as part of our package, so make sure to install the package. You can then run: pip install flake8 flake8 . Formatting We black for code formatting. Make sure to install package, and then run: pip install black black . Type Checking Lastly, we use mypy for type checking. Make sure to instal the package to run: pip install mypy python3 -m mypy . Continuous Integration We use GitHub Actions to automatically run our entire test suite upon each push . Check out the file .github/workflows/testing.yml to edit the testing workflow, and .github/workflows/testing.yml to edit the linting workflow. Documentation We use MkDocs for our documentation. To set up and make edits to our documentation, first install the MkDocs package: pip install mkdocs Then, making sure you're in the same directory as the mkdocs.yml configuration file, you can start the server by running the command: mkdocs serve For more tips, check out their documentation .","title":"Contribution Guide"},{"location":"contribution-guide/#contribution-guide","text":"To get started on contributing, check out the below guide on how to get the package installed locally, how to update this documentation website, and more.","title":"Contribution Guide"},{"location":"contribution-guide/#how-to-set-up","text":"To set up our codebase, create a virtual environment and install a local copy of the package. python3 -m venv env source env/bin/activate cd pyrorl/ pip install .","title":"How to Set-Up"},{"location":"contribution-guide/#package-deployment","text":"All of the details of the package can be found in pyrorl/setup.py . This file defines attributes such as the name of the package, the version number, and the dependencies needed to use the package. Next, you build the distribution archives. Archives are compressed files that allow the package to be deployed across multiple platforms. You run the following command to generate the distribution files: python3 setup.py sdist Using the above command should generate a dist folder, which contains the compressed distribution files. Finally, we can publish it to the official PyPi repository using a package called twine : twine upload dist/* Doing the * will upload all of the compressed distribution files, so ideally, we would clear out all of them and then have only one set of distribution files.","title":"Package Deployment"},{"location":"contribution-guide/#coding-standards","text":"","title":"Coding Standards"},{"location":"contribution-guide/#testing","text":"We use pytest for our backend tests. To keep the state of our package as small as possible, we don't include pytest . Thus, make sure to install the package before running. pip install pytest python3 -m pytest -s","title":"Testing"},{"location":"contribution-guide/#linting","text":"We use flake8 for linting. We also don't install flake8 as part of our package, so make sure to install the package. You can then run: pip install flake8 flake8 .","title":"Linting"},{"location":"contribution-guide/#formatting","text":"We black for code formatting. Make sure to install package, and then run: pip install black black .","title":"Formatting"},{"location":"contribution-guide/#type-checking","text":"Lastly, we use mypy for type checking. Make sure to instal the package to run: pip install mypy python3 -m mypy .","title":"Type Checking"},{"location":"contribution-guide/#continuous-integration","text":"We use GitHub Actions to automatically run our entire test suite upon each push . Check out the file .github/workflows/testing.yml to edit the testing workflow, and .github/workflows/testing.yml to edit the linting workflow.","title":"Continuous Integration"},{"location":"contribution-guide/#documentation","text":"We use MkDocs for our documentation. To set up and make edits to our documentation, first install the MkDocs package: pip install mkdocs Then, making sure you're in the same directory as the mkdocs.yml configuration file, you can start the server by running the command: mkdocs serve For more tips, check out their documentation .","title":"Documentation"},{"location":"how-it-works/","text":"How it works Wildfire Evacuation as a Markov Decision Process Overview of State Space The state space is each possible configuration of the grid. Internally, this is represented as a \\(5\\) by \\(m\\) by \\(n\\) tensor, where \\(m\\) and \\(n\\) represent the number of rows and columns of the grid world respectively. Each of the \\(5\\) indices corresponds to a specific attribute: 0 = FIRE_INDEX \u2013 whether or not a square in the grid world is on fire or not 1 = FUEL_INDEX \u2013 the amount of fuel in the square, which is used to determine if an area will be enflamed or not 2 = POPULATED_INDEX \u2013 whether or not a square is a populated area or not 3 = EVACUATING_INDEX \u2013 whether or not a square is evacuating or not 4 = PATHS_INDEX \u2013 the number of paths a square is a part of Overview of Action Space The action space describes whether or not a populated area should evacuate. If evacuating, the agent must choose a specific populated area to evacuate, as well as a path from which to evacuate. Transition Model: determined by the stochastic nature of the wildfire implementation, which we describe below Reward Model: \\(+1\\) for every populated area that has not evacuated and is not ignited, and \\(-100\\) if a populated area is burned down Spread of Wildfire Finally, our stochastic wildfire model is based on prior work : Fuel Each fire cell has an initial fuel level \\(\\sim \\mathcal{N}(\\mu, \\, (\\sigma)^{2})\\) A cell currently on fire has its fuel level drop by \\(1\\) after each time step until it runs out of fuel Users can configure \\(\\mu\\) and \\(\\sigma\\) . By defualt, their respective values are \\(\\mu=8.5\\) and \\(\\sigma=\\sqrt 3\\) Fire Spread We define the spread of the fire by the following equation: \\(p(s)=1-\\Pi_{s'}(1 - \\lambda \\cdot d(s,s') \\cdot B(s'))\\) \\(p(s)\\) represents the probability of non-inflamed cell \\(s\\) alighting \\(s'\\) represents an adjacent cell \\(\\lambda\\) is a hyperparameter that affects the probability of fire spreading from one cell to an adjacent one \\(d(s,s')\\) is the Euclidean distance between cells \\(B(s)\\) is a Boolean to check if cell is currently on fire Users can configure \\(\\lambda\\) . By defualt, the value is \\(\\lambda=0.094\\) . Wind The spread of wildfire is also influenced by wind. This bias is modeled through a linear transformation using two properties. First, the wind speed affects the probability of neighboring cells igniting the current cell. In addition, for each cell, we calculate the vectors that point in the direction of each neighboring cell. We then take the dot product between this vector and the direction of the wind. Custom Map Generation How to Load and Generate Maps To generate and load maps, the two functions of note are generate_map_info and load_map_info located within the create_map_info.py file in the map_helpers directory. For the generate_map_info function, the main parameters that the user must provide are the size of the grid -- in terms of the number of rows ( num_rows ) and the number of columns ( num_cols ) -- and the number of populated cells the user would like the map to have ( num_populated_areas ). The maps are saved automatically, but this behavior can be turned off by setting the save_map parameter to False . Furthermore, the number of steps that are taken each iteration (every time a direction is chosen) are randomly chosen in the range stipulated by steps_lower_bound and steps_upper_bound which are 2 and 4 by default. The standard behavior of the map generation is to favor going straight \\(50\\) % of the time, but this behavior can be changed by altering the percent_go_straight parameter. The number of paths generated for each populated area are also selected from a normal distribution with a mean of \\(3\\) and standard deviation of \\(1\\) , but these values can be altered by specifying the num_paths_mean and num_paths_stdev parameters. If the save_map parameter is set to True when generating maps (the default behavior), the map is saved to the user\u2019s current working directory by first creating a new subdirectory called pyrorl_map_info which stores all the subdirectories created for each subsequent map generation. For a given map generation, a new subdirectory is created within the pyrorl_map_info folder that is titled with the timestamp of when the map was created. Within this folder is a text file that is present for the user to easily see the number of rows, number of columns, and number of populated areas for the generation. This folder also contains pickle files that store the populated_areas array, paths array, paths_to_pops array, and a list that contains the number of rows, number of columns, and number of populated areas. To load in a map, the path for the directory containing the relevant map information must be provided to the load_map_info function (by default, the title of the directory will by a timestamp). This function will then return the number of rows, the number of columns, the populated_areas array, the paths array, the paths_to_pops array, and the number of populated areas. Deep Dive on Map Generation Implementation As a quick note, know that paths are allowed to overlap with each other and that paths can proceed through other populated areas. In terms of the actual implementation of the map generation code, the populated areas are first randomly generated on the grid. These populated areas cannot be generated on the edge of the grid. Once the populated areas are selected, the number of paths for each area are then selected from a normal distribution with the mean and standard deviation taken from the provided parameters. Each path is then generated for their respective populated area. Each path is generated starting from the coordinates of their respective populated areas. When creating a path, orientation and direction lie at the heart of the generation. Orientation is the cardinal direction an individual would be facing if they were to walk straight along the path, with north pointing to the top of the map (lower values of rows), south pointing to the bottom of the map (higher values of rows), east pointing to the right of the map (higher values of columns), and west pointing to the left of the map (lower values of columns). At the start of the map generation, the beginning orientation is selected randomly. Direction refers to how a person would proceed if they were to continue walking along the path given their current orientation, with the three directions being left, right, and straight. To update a path, a direction is first chosen. Once a direction is chosen, the orientation is updated and the path is extended along the new orientation for a given number of steps which is randomly chosen as a value between a given lower bound and upper bound provided as a parameter (2 and 3 by default). This process continues until the path reaches the edge of the map. As an example of a generation iteration, consider the current orientation being \u201ceast\u201d and the number of steps being 3. If the direction chosen is straight, the path will continue to extend east 3 steps. If the direction chosen is left, the orientation will change to north and the path will extend north 3 steps. If the direction chosen is right, the orientation will change to south and the path will extend south 3 steps. Lastly, the code was designed so that paths will not overlap/intersect with themselves, meaning that as the paths are generated they will continue to proceed outwards towards the edge of the map. This is achieved by noting the minimum and maximum row index and minimum and maximum column index that the path has reached so far. There are then some special restrictions for each orientation on whether or not they can turn left or right (i.e. not proceed straight). If the orientation is north, then to take a turn the horizon (i.e. edge) of the path must currently be the minimum row index. If the orientation is south, then to take a turn the horizon (i.e. edge) of the path must currently be the maximum row index. If the orientation is east, then to take a turn the horizon (i.e. edge) of the path must currently be the maximum column index. If the orientation is west, then to take a turn the horizon (i.e. edge) of the path must currently be the minimum column index.","title":"How It Works"},{"location":"how-it-works/#how-it-works","text":"","title":"How it works"},{"location":"how-it-works/#wildfire-evacuation-as-a-markov-decision-process","text":"","title":"Wildfire Evacuation as a Markov Decision Process"},{"location":"how-it-works/#overview-of-state-space","text":"The state space is each possible configuration of the grid. Internally, this is represented as a \\(5\\) by \\(m\\) by \\(n\\) tensor, where \\(m\\) and \\(n\\) represent the number of rows and columns of the grid world respectively. Each of the \\(5\\) indices corresponds to a specific attribute: 0 = FIRE_INDEX \u2013 whether or not a square in the grid world is on fire or not 1 = FUEL_INDEX \u2013 the amount of fuel in the square, which is used to determine if an area will be enflamed or not 2 = POPULATED_INDEX \u2013 whether or not a square is a populated area or not 3 = EVACUATING_INDEX \u2013 whether or not a square is evacuating or not 4 = PATHS_INDEX \u2013 the number of paths a square is a part of","title":"Overview of State Space"},{"location":"how-it-works/#overview-of-action-space","text":"The action space describes whether or not a populated area should evacuate. If evacuating, the agent must choose a specific populated area to evacuate, as well as a path from which to evacuate. Transition Model: determined by the stochastic nature of the wildfire implementation, which we describe below Reward Model: \\(+1\\) for every populated area that has not evacuated and is not ignited, and \\(-100\\) if a populated area is burned down","title":"Overview of Action Space"},{"location":"how-it-works/#spread-of-wildfire","text":"Finally, our stochastic wildfire model is based on prior work :","title":"Spread of Wildfire"},{"location":"how-it-works/#fuel","text":"Each fire cell has an initial fuel level \\(\\sim \\mathcal{N}(\\mu, \\, (\\sigma)^{2})\\) A cell currently on fire has its fuel level drop by \\(1\\) after each time step until it runs out of fuel Users can configure \\(\\mu\\) and \\(\\sigma\\) . By defualt, their respective values are \\(\\mu=8.5\\) and \\(\\sigma=\\sqrt 3\\)","title":"Fuel"},{"location":"how-it-works/#fire-spread","text":"We define the spread of the fire by the following equation: \\(p(s)=1-\\Pi_{s'}(1 - \\lambda \\cdot d(s,s') \\cdot B(s'))\\) \\(p(s)\\) represents the probability of non-inflamed cell \\(s\\) alighting \\(s'\\) represents an adjacent cell \\(\\lambda\\) is a hyperparameter that affects the probability of fire spreading from one cell to an adjacent one \\(d(s,s')\\) is the Euclidean distance between cells \\(B(s)\\) is a Boolean to check if cell is currently on fire Users can configure \\(\\lambda\\) . By defualt, the value is \\(\\lambda=0.094\\) .","title":"Fire Spread"},{"location":"how-it-works/#wind","text":"The spread of wildfire is also influenced by wind. This bias is modeled through a linear transformation using two properties. First, the wind speed affects the probability of neighboring cells igniting the current cell. In addition, for each cell, we calculate the vectors that point in the direction of each neighboring cell. We then take the dot product between this vector and the direction of the wind.","title":"Wind"},{"location":"how-it-works/#custom-map-generation","text":"","title":"Custom Map Generation"},{"location":"how-it-works/#how-to-load-and-generate-maps","text":"To generate and load maps, the two functions of note are generate_map_info and load_map_info located within the create_map_info.py file in the map_helpers directory. For the generate_map_info function, the main parameters that the user must provide are the size of the grid -- in terms of the number of rows ( num_rows ) and the number of columns ( num_cols ) -- and the number of populated cells the user would like the map to have ( num_populated_areas ). The maps are saved automatically, but this behavior can be turned off by setting the save_map parameter to False . Furthermore, the number of steps that are taken each iteration (every time a direction is chosen) are randomly chosen in the range stipulated by steps_lower_bound and steps_upper_bound which are 2 and 4 by default. The standard behavior of the map generation is to favor going straight \\(50\\) % of the time, but this behavior can be changed by altering the percent_go_straight parameter. The number of paths generated for each populated area are also selected from a normal distribution with a mean of \\(3\\) and standard deviation of \\(1\\) , but these values can be altered by specifying the num_paths_mean and num_paths_stdev parameters. If the save_map parameter is set to True when generating maps (the default behavior), the map is saved to the user\u2019s current working directory by first creating a new subdirectory called pyrorl_map_info which stores all the subdirectories created for each subsequent map generation. For a given map generation, a new subdirectory is created within the pyrorl_map_info folder that is titled with the timestamp of when the map was created. Within this folder is a text file that is present for the user to easily see the number of rows, number of columns, and number of populated areas for the generation. This folder also contains pickle files that store the populated_areas array, paths array, paths_to_pops array, and a list that contains the number of rows, number of columns, and number of populated areas. To load in a map, the path for the directory containing the relevant map information must be provided to the load_map_info function (by default, the title of the directory will by a timestamp). This function will then return the number of rows, the number of columns, the populated_areas array, the paths array, the paths_to_pops array, and the number of populated areas.","title":"How to Load and Generate Maps"},{"location":"how-it-works/#deep-dive-on-map-generation-implementation","text":"As a quick note, know that paths are allowed to overlap with each other and that paths can proceed through other populated areas. In terms of the actual implementation of the map generation code, the populated areas are first randomly generated on the grid. These populated areas cannot be generated on the edge of the grid. Once the populated areas are selected, the number of paths for each area are then selected from a normal distribution with the mean and standard deviation taken from the provided parameters. Each path is then generated for their respective populated area. Each path is generated starting from the coordinates of their respective populated areas. When creating a path, orientation and direction lie at the heart of the generation. Orientation is the cardinal direction an individual would be facing if they were to walk straight along the path, with north pointing to the top of the map (lower values of rows), south pointing to the bottom of the map (higher values of rows), east pointing to the right of the map (higher values of columns), and west pointing to the left of the map (lower values of columns). At the start of the map generation, the beginning orientation is selected randomly. Direction refers to how a person would proceed if they were to continue walking along the path given their current orientation, with the three directions being left, right, and straight. To update a path, a direction is first chosen. Once a direction is chosen, the orientation is updated and the path is extended along the new orientation for a given number of steps which is randomly chosen as a value between a given lower bound and upper bound provided as a parameter (2 and 3 by default). This process continues until the path reaches the edge of the map. As an example of a generation iteration, consider the current orientation being \u201ceast\u201d and the number of steps being 3. If the direction chosen is straight, the path will continue to extend east 3 steps. If the direction chosen is left, the orientation will change to north and the path will extend north 3 steps. If the direction chosen is right, the orientation will change to south and the path will extend south 3 steps. Lastly, the code was designed so that paths will not overlap/intersect with themselves, meaning that as the paths are generated they will continue to proceed outwards towards the edge of the map. This is achieved by noting the minimum and maximum row index and minimum and maximum column index that the path has reached so far. There are then some special restrictions for each orientation on whether or not they can turn left or right (i.e. not proceed straight). If the orientation is north, then to take a turn the horizon (i.e. edge) of the path must currently be the minimum row index. If the orientation is south, then to take a turn the horizon (i.e. edge) of the path must currently be the maximum row index. If the orientation is east, then to take a turn the horizon (i.e. edge) of the path must currently be the maximum column index. If the orientation is west, then to take a turn the horizon (i.e. edge) of the path must currently be the minimum column index.","title":"Deep Dive on Map Generation Implementation"},{"location":"quickstart/","text":"Quickstart Installation First, download our Python package: pip install pyrorl Basic Usage Environment Definition To use our environment, you need to define five parameters: num_rows and num_cols \u2013 these two integers define a ( num_rows , num_cols ) grid world populated_areas \u2013 an array of [x, y] coordinates that indicate the location of the populated areas paths \u2013 an array of paths. Each path is an array of [x, y] coordinates that indicate each square in a path paths_to_pops \u2013 a dictionary that maps paths to which populated areas can use those paths. The keys are integers that represent the index of the path in the paths array. The values are arrays of integers that represent the populated area in the populated_areas array. Creating Maps To create a map, you can specify each of the above parameters manually: num_rows, num_cols = 10, 10 populated_areas = np.array([[1,2],[4,8], [6,4], [8, 7]]) paths = np.array([[[1,0],[1,1]], [[2,2],[3,2],[4,2],[4,1],[4,0]], [[2,9],[2,8],[3,8]], [[5,8],[6,8],[6,9]], [[7,7], [6,7], [6,8], [6,9]], [[8,6], [8,5], [9,5]], [[8,5], [9,5], [7,5],[7,4]]], dtype=object) paths_to_pops = {0:[[1,2]], 1:[[1,2]], 2: [[4,8]], 3:[[4,8]], 4:[[8, 7]], 5:[[8, 7]], 6:[[6,4]]} We also provide functionality to generate custom maps programmatically. If you import pyrorl.map_helpers.create_map_info , you can create your own maps by specificying just a few parameters: # Import map helpers from pyrorl.map_helpers.create_map_info import ( generate_map_info, MAP_DIRECTORY, load_map_info, ) # Set up parameters num_rows, num_cols = 20, 20 num_populated_areas = 5 # example of generating map (other parameters are set to their default values) populated_areas, paths, paths_to_pops = generate_map_info( num_rows, num_cols, num_populated_areas, save_map=True, steps_lower_bound=2, steps_upper_bound=4, percent_go_straight=50, num_paths_mean=3, num_paths_stdev=1, ) If you set the save_map parameter to be True , you can also save the map configuration information to be used at a later time. You can then later load in the information for use: # showing how to load in the most recent map created for good measure, # would otherwise just provide the desired map path to load_map_info # (i.e. only use the last line with load_map_info) map_info_root = os.path.join(os.getcwd(), MAP_DIRECTORY) current_map_directory = max( os.listdir(map_info_root), key=lambda f: os.path.getctime(os.path.join(map_info_root, f)), ) map_info_path = os.path.join(map_info_root, current_map_directory) num_rows, num_cols, populated_areas, paths, paths_to_pops, num_populated_areas = ( load_map_info(map_info_path) ) Running the Environment Using these parameters, you can then define them as kwargs and use gymnasium.make to create the environment: # Note that additional parameters are listed (i.e. all parameters past paths_to_pops below). # These are currently set to their default values but can also be specified by the user. kwargs = { 'num_rows': num_rows, 'num_cols': num_cols, 'populated_areas': populated_areas, 'paths': paths, 'paths_to_pops': paths_to_pops, 'num_fire_cells': 2, 'custom_fire_locations': None, # would be a numpy array of locations if specified 'wind_speed': None, # would be a float if specified 'wind_angle': None, # would be a float if specified 'fuel_mean': 8.5, 'fuel_stdev': 3, 'fire_propagation_rate': 0.094 } env = gymnasium.make('pyrorl/PyroRL-v0', **kwargs) The wildfire environment has the following action and state/observation space: action_space: [0, number of paths] observation_space: (5, num_rows, num_cols) tensor, where every value in each dimension is between [0, 200] Now, with all of this information, we can create a loop that samples an action from the action space, takes a step with the action, and renders the environment: env.reset() for _ in range(20): # Take action and observation action = env.action_space.sample() observation, reward, terminated, truncated, info = env.step(action) # Render environment and print reward env.render() print(\"Reward: \" + str(reward)) # Generate the gif env.generate_gif() Rendering the Environment Finally, we can see that the function generate_gif allows us to collate all of the visualizations generated by the render function and stitch them together into a GIF: Use with Stable Baselines 3 Stable Baselines 3 is a popular library for reinforcement learning algorithms. You can use Stable Baseline algorithms to find optimal policies for the wildfire evacuation problem. Given that our environment conforms to the gymnasium specification, training a model is no different than with other environments: # Train a model and delete model = DQN(\"MlpPolicy\", env, verbose=1) model.learn(total_timesteps=1000, log_interval=4) model.save(\"sample_baseline\") del model The same is true for using the model during evaluation: # Load and reset the environment model = DQN.load(\"sample_baseline\") obs, info = env.reset() # Run a simple loop of the environment for _ in range(10): action, _states = model.predict(obs, deterministic=True) observation, reward, terminated, truncated, info = env.step(int(action)) # Render environment and print reward env.render() print(\"Reward: \" + str(reward))","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#installation","text":"First, download our Python package: pip install pyrorl","title":"Installation"},{"location":"quickstart/#basic-usage","text":"","title":"Basic Usage"},{"location":"quickstart/#environment-definition","text":"To use our environment, you need to define five parameters: num_rows and num_cols \u2013 these two integers define a ( num_rows , num_cols ) grid world populated_areas \u2013 an array of [x, y] coordinates that indicate the location of the populated areas paths \u2013 an array of paths. Each path is an array of [x, y] coordinates that indicate each square in a path paths_to_pops \u2013 a dictionary that maps paths to which populated areas can use those paths. The keys are integers that represent the index of the path in the paths array. The values are arrays of integers that represent the populated area in the populated_areas array.","title":"Environment Definition"},{"location":"quickstart/#creating-maps","text":"To create a map, you can specify each of the above parameters manually: num_rows, num_cols = 10, 10 populated_areas = np.array([[1,2],[4,8], [6,4], [8, 7]]) paths = np.array([[[1,0],[1,1]], [[2,2],[3,2],[4,2],[4,1],[4,0]], [[2,9],[2,8],[3,8]], [[5,8],[6,8],[6,9]], [[7,7], [6,7], [6,8], [6,9]], [[8,6], [8,5], [9,5]], [[8,5], [9,5], [7,5],[7,4]]], dtype=object) paths_to_pops = {0:[[1,2]], 1:[[1,2]], 2: [[4,8]], 3:[[4,8]], 4:[[8, 7]], 5:[[8, 7]], 6:[[6,4]]} We also provide functionality to generate custom maps programmatically. If you import pyrorl.map_helpers.create_map_info , you can create your own maps by specificying just a few parameters: # Import map helpers from pyrorl.map_helpers.create_map_info import ( generate_map_info, MAP_DIRECTORY, load_map_info, ) # Set up parameters num_rows, num_cols = 20, 20 num_populated_areas = 5 # example of generating map (other parameters are set to their default values) populated_areas, paths, paths_to_pops = generate_map_info( num_rows, num_cols, num_populated_areas, save_map=True, steps_lower_bound=2, steps_upper_bound=4, percent_go_straight=50, num_paths_mean=3, num_paths_stdev=1, ) If you set the save_map parameter to be True , you can also save the map configuration information to be used at a later time. You can then later load in the information for use: # showing how to load in the most recent map created for good measure, # would otherwise just provide the desired map path to load_map_info # (i.e. only use the last line with load_map_info) map_info_root = os.path.join(os.getcwd(), MAP_DIRECTORY) current_map_directory = max( os.listdir(map_info_root), key=lambda f: os.path.getctime(os.path.join(map_info_root, f)), ) map_info_path = os.path.join(map_info_root, current_map_directory) num_rows, num_cols, populated_areas, paths, paths_to_pops, num_populated_areas = ( load_map_info(map_info_path) )","title":"Creating Maps"},{"location":"quickstart/#running-the-environment","text":"Using these parameters, you can then define them as kwargs and use gymnasium.make to create the environment: # Note that additional parameters are listed (i.e. all parameters past paths_to_pops below). # These are currently set to their default values but can also be specified by the user. kwargs = { 'num_rows': num_rows, 'num_cols': num_cols, 'populated_areas': populated_areas, 'paths': paths, 'paths_to_pops': paths_to_pops, 'num_fire_cells': 2, 'custom_fire_locations': None, # would be a numpy array of locations if specified 'wind_speed': None, # would be a float if specified 'wind_angle': None, # would be a float if specified 'fuel_mean': 8.5, 'fuel_stdev': 3, 'fire_propagation_rate': 0.094 } env = gymnasium.make('pyrorl/PyroRL-v0', **kwargs) The wildfire environment has the following action and state/observation space: action_space: [0, number of paths] observation_space: (5, num_rows, num_cols) tensor, where every value in each dimension is between [0, 200] Now, with all of this information, we can create a loop that samples an action from the action space, takes a step with the action, and renders the environment: env.reset() for _ in range(20): # Take action and observation action = env.action_space.sample() observation, reward, terminated, truncated, info = env.step(action) # Render environment and print reward env.render() print(\"Reward: \" + str(reward)) # Generate the gif env.generate_gif()","title":"Running the Environment"},{"location":"quickstart/#rendering-the-environment","text":"Finally, we can see that the function generate_gif allows us to collate all of the visualizations generated by the render function and stitch them together into a GIF:","title":"Rendering the Environment"},{"location":"quickstart/#use-with-stable-baselines-3","text":"Stable Baselines 3 is a popular library for reinforcement learning algorithms. You can use Stable Baseline algorithms to find optimal policies for the wildfire evacuation problem. Given that our environment conforms to the gymnasium specification, training a model is no different than with other environments: # Train a model and delete model = DQN(\"MlpPolicy\", env, verbose=1) model.learn(total_timesteps=1000, log_interval=4) model.save(\"sample_baseline\") del model The same is true for using the model during evaluation: # Load and reset the environment model = DQN.load(\"sample_baseline\") obs, info = env.reset() # Run a simple loop of the environment for _ in range(10): action, _states = model.predict(obs, deterministic=True) observation, reward, terminated, truncated, info = env.step(int(action)) # Render environment and print reward env.render() print(\"Reward: \" + str(reward))","title":"Use with Stable Baselines 3"}]}